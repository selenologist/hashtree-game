use sodiumoxide::crypto::sign::ed25519::{PublicKey};
use rpds::{HashTrieSet, HashTrieMap};
use tokio_core::{self};//, reactor::Handle};
use futures::{sync::{mpsc::{UnboundedReceiver, UnboundedSender,
                            unbounded as unbounded_channel},
                     oneshot::{Receiver as OneshotReceiver, Sender as OneshotSender,
                               Canceled as OneshotCanceled,
                               channel as oneshot}},
              Future,
              Stream};
use serde::{Serialize, Deserialize};
use rmp_serde::to_vec_named as serialize;

use std::thread;
use std::io;

use verify::{Verifier, VerifierMap, VerifierError, store_verified};
use signed::{Signed, KeyPair};
use block::{BlockStore, BlockData, BlockHash};
use update::{Command, NamedHash, NamedHashCommand};

/* later
type TileId = u8;
const NUM_ANIMATED_TILES:   usize = 32;
const NUM_STATIC_TILES:     usize = 256 - NUM_ANIMATED_TILES;
const NUM_ANIMATION_FRAMES: usize = 4;

type TileSet = [Option<BlockHash>; 256];

#[derive(Serialize, Deserialize, Debug)]
struct TileAtlas{
    atlas: BlockHash, // png containing 256 tiles
    /* map of the last NUM_ANIMATED_TILES TileIds to the NUM_ANIMATION_FRAMES tiles
    // that make up the tile animation
    animated: [[TileId; NUM_ANIMATION_FRAMES]; NUM_ANIMATED_TILES] */
}

#[derive(Serialize, Deserialize, Debug)]
struct MapLayer{
    atlas: String,
    tiles: Vec<TileId>
}

#[derive(Serialize, Deserialize, Debug)]
struct Map{
    width:  u16,
    height: u16,
    layers: Vec<MapLayer>,
    links:  [Option<BlockHash>; 4] // connected map for each cardinal direction
}*/

use hyper::{Request, Response};
type PathString        = String;
type MapThreadSender   = UnboundedSender<(Request, PathString, MapResponder)>;
type MapThreadReceiver = UnboundedReceiver<(Request, PathString, MapResponder)>;
type MapResponder      = OneshotSender<Response>;
type MapResponse       = OneshotReceiver<Response>;

#[derive(Serialize, Deserialize, Debug)]
#[serde(tag="Req")]
pub enum VerifierRequest{
    Latest,
    Update(Signed)
}

type FileThreadResponder = OneshotSender<Response>;

#[derive(Debug, Serialize)]
#[serde(tag="Response", content="Result")]
enum VerifierResponse{
    Latest(Option<BlockHash>),
    VerifierResult(Result<BlockHash, VerifierError>)
}

struct MapThread{
    store: BlockStore,
    tile_libraries: VerifierMap,
    root_key: PublicKey
}

impl MapThread{
    fn new(store: BlockStore, root_key: PublicKey) -> MapThread{
        const TILE_LIBRARY_DIR: &'static str = "secret/tile_library/";
        const MAP_VERIFIER_KEY: &'static str = "secret/map_verifier";

        let kp = KeyPair::from_file_or_new(MAP_VERIFIER_KEY);
        let empty_namedhash = // get hash of a namedhash root signed by the MAP_VERIFIER_KEY
            store_verified(&store,
                           NamedHash(HashTrieMap::<String, BlockHash>::new()),
                           &kp)
            .unwrap(); // XXX handle this properly
                                             
        MapThread{
            store,
            tile_libraries: VerifierMap::from_dir(TILE_LIBRARY_DIR)
                .unwrap_or_else(|e| {
                    error!("Failed to load tile library VerifierMap({}), creating new",
                           e);
                    let mut vm = VerifierMap::new(TILE_LIBRARY_DIR);
                    let allowed = HashTrieSet::new().insert(root_key.clone());
                    vm.add_new("main".into(),
                               Some(kp.clone()),
                               Some(allowed),
                               Some(empty_namedhash))
                      .unwrap(); // shouldn't be able to fail, should contain no existing
                    vm.to_dir().unwrap(); // very much can fail XXX
                    vm
                }),
            root_key,
        }
    }
    fn run(mut self, receiver: MapThreadReceiver){
        let mut core = tokio_core::reactor::Core::new().unwrap();
        let handle = core.handle();

        let main = receiver.for_each(|(req, path, responder)| {
            use hyper::{Method, header::{ContentLength, ContentType}, StatusCode};
            use regex::{Regex, RegexSet};

            const MAPLIBRARY_STR: &'static str = r"/map/library/([^/]+)(/(.+))?";
            const MAPLIBRARY_INDEX: usize = 0;
            lazy_static!{
                static ref MAPLIBRARY_REGEX: Regex =
                    Regex::new(MAPLIBRARY_STR).unwrap();
                static ref VALID_COMMANDS: RegexSet =
                    RegexSet::new(&[MAPLIBRARY_STR]).unwrap();
            }

            let ise = |responder: MapResponder, s: String|{
                let error_page = format!("<h1>Internal Server Error</h1><h2>{}</h2><hr/><tt>Generated by MapThread</tt>",
                                         s);
                responder.send(
                    Response::new()
                        .with_header(ContentLength(error_page.len() as u64))
                        .with_header(ContentType::html())
                        .with_status(StatusCode::InternalServerError)
                        .with_body(error_page)).unwrap();
            };

            let send_data = |responder: MapResponder, d: Vec<u8>|
                responder.send(
                    Response::new()
                        .with_header(ContentLength(d.len() as u64))
                        .with_status(StatusCode::Ok)
                        .with_body(d)).unwrap();
            
            let send_block = |responder: MapResponder, b: io::Result<BlockData>| match b{
                Ok(d) =>
                    send_data(responder, *d.clone()),
                Err(e) =>
                    ise(responder, format!("{:?}", e))
            };

            let block_response = |responder, b|
                handle.spawn(
                    self.store.get(b).then(|r|{
                        match r{
                            Ok(k) => send_block(responder, k),
                            Err(e) => ise(responder, "BlockStore cancelled its responder".to_string())
                        }
                        Ok(())
                    }));


            let method = req.method();
            let command = VALID_COMMANDS.matches(path.as_ref());
            if command.matched(MAPLIBRARY_INDEX){
                let captures = MAPLIBRARY_REGEX.captures(path.as_ref()).unwrap(); // shouldn't fail
                let lib_name = captures.get(1).unwrap().as_str(); // shouldn't fail
                // XXX maybe handle retreiving specific tile
                if method == &Method::Get{
                    if let VerifierResponse::Latest(latest) =
                        verifier::<NamedHash, NamedHashCommand>(&self.store,
                                                                &mut self.tile_libraries,
                                                                lib_name.to_string(),
                                                                VerifierRequest::Latest)
                    {
                        send_data(responder, serialize(&latest).unwrap())
                    }
                } else if method == &Method::Put{
                    panic!("blah");
                    // VerifierRequest::Update(
                    // XXX sync less often, this is EXTREMELY inefficient!
                    self.tile_libraries
                        .to_dir()
                        .unwrap();
                }
            }

            Ok(())
        });

        core.run(main).unwrap();
    }
}

fn verifier<T, C>(store: &BlockStore, vmap: &mut VerifierMap, name: String, vreq: VerifierRequest)
    -> VerifierResponse
        where for <'de> T: Deserialize<'de>,
              for <'de> C: Deserialize<'de>,
              T: Serialize + ::std::fmt::Debug,
              C: Command<T>
{
    use self::VerifierRequest::{Latest as ReqLatest, *};
    use self::VerifierResponse::{Latest as RespLatest, *};
    match vreq{
       ReqLatest =>
           RespLatest(vmap.latest(&name)),
       Update(signed) =>
           VerifierResult(
               vmap.verify::<T,C>(store, signed, &name)
                   .wait())
    }
}

#[derive(Debug, Clone)]
pub struct MapThreadHandle(MapThreadSender);

impl MapThreadHandle{
    pub fn call(&self, req: Request, path: PathString)
        -> impl Future<Item=Response, Error=OneshotCanceled>
    {
        let (responder, response) = oneshot();
        if let Err(_) = self.0.unbounded_send((req, path, responder)){
            error!("MapThread closed its Receiver!");
            panic!("MapThread closed its Receiver!");
        }
        response
    }
}

pub fn spawn_thread(store: BlockStore, root_key: PublicKey) -> MapThreadHandle{
    let (sender, receiver) = unbounded_channel();

    let _thread = thread::Builder::new()
        .name("Map".into())
        .spawn(move ||{
            let map = MapThread::new(store, root_key);
            map.run(receiver);
        });

    MapThreadHandle(sender)
}


